#!/usr/bin/env python3
#
# Copyright (c) 2017, Thomas Farr
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

"""bin2s.py: Convert binary files to GCC asm modules.

For gfx/foo.bin it will write foo_bin (an array of char), foo_bin_end, and foo_bin_size (an unsigned int).
For 4bit.chr it will write _4bit_chr, _4bit_chr_end, and _4bit_chr_size.

Ported to python from https://github.com/devkitPro/general-tools/blob/master/bin2s.c"""


import argparse
import os.path
import re
import sys


_default_alignment = 4
_default_line_length = 16
_assembly_template = '''\
/* Generated by BIN2S - please don't edit directly */
  .section .rodata
  .balign {alignment}
  .global {identifier}_size
  .global {identifier}
{identifier}:
{data}

  .global {identifier}_end
{identifier}_end:

  .align
{identifier}_size: .int {size}
'''


def safe_identifier(src):
    return re.sub(r'^(\d)', '_\\1', re.sub(r'[./-]', '_', re.sub(r'[^A-Za-z0-9_./-]', '', src)))


def bin2s(file_path, alignment=_default_alignment, line_length=_default_line_length, output=sys.stdout):
    try:
        with open(file_path, 'rb') as fin:
            fin.seek(0, 2)
            file_len = fin.tell()
            fin.seek(0)

            if file_len == 0:
                print('bin2s: warning: skipping empty file \'%s\'' % file_path, file=sys.stderr)
                return True

            data = ''
            count = file_len
            while count > 0:
                line_bytes = fin.read(line_length)
                data += '  .byte %s\n' % ','.join(map(lambda b: '%3u' % b, line_bytes))
                count -= len(line_bytes)
            data = data[:-1]

            identifier = safe_identifier(os.path.basename(file_path))

            print(_assembly_template.format(identifier=identifier, alignment=alignment, data=data, size=file_len),
                  end='', file=output)

            return True
    except IOError as e:
        print('bin2s: error: could not open \'%s\': %s' % (file_path, e.strerror), file=sys.stderr)
        return False


def main():
    parser = argparse.ArgumentParser(
        description='''Convert binary files to GCC asm modules.\n\n
                       For gfx/foo.bin it will write foo_bin (an array of char), foo_bin_end, and foo_bin_size (an unsigned int).
                       For 4bit.chr it will write _4bit_chr, _4bit_chr_end, and _4bit_chr_size.''')
    parser.add_argument('files', metavar='FILE', nargs='+',
                        help='Binary file to convert to GCC asm')
    parser.add_argument('-a', '--alignment',
                        help='Boundary alignment, in bytes [default: %(default)s]',
                        dest='alignment', type=int, default=_default_alignment)
    parser.add_argument('-l', '--line-length',
                        help='Length of data lines to output, in bytes [default: %(default)s]',
                        dest='line_length', type=int, default=_default_line_length)
    parser.add_argument('-o', '--output',
                        help='Output file [default: %(default)s]',
                        dest='output', default='-')
    args = parser.parse_args()

    alignment = _default_alignment if args.alignment <= 0 else args.alignment
    line_length = _default_line_length if args.line_length <= 0 else args.line_length

    try:
        output = open(args.output, 'w') if args.output != '-' else sys.stdout
    except IOError as e:
        print('bin2s: error: could not open \'%s\' for writing: %s' % (options.output, e.strerror),
              file=sys.stderr)
        return 1

    for file_path in args.files:
        if not bin2s(file_path, alignment=alignment, line_length=line_length, output=output):
            return 1

    if args.output != '-':
        output.close()

if __name__ == '__main__':
    sys.exit(main())
